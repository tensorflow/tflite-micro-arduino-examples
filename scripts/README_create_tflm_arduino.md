# README for the [create_tflm_arduino](create_tflm_arduino.py) script.
This python 3.x script is used to create an `output directory` containing all the
files necessary for a TensorFlow Lite Micro (TFLM) library.  The created TFLM
library is ready for use with the Arduino IDE. The `output directory` can also
be used to update the
[Arduino Examples repository](https://github.com/tensorflow/tflite-micro-arduino-examples)
by the repository maintainers.

The [create_tflm_arduino](create_tflm_arduino.py) script accepts the following
arguments:
* `--output_dir`

    The `output directory` for the TFLM library to be created.
* `--base_dir`

    This is the `base directory` containing a base set of files from the
    [TFLM repository](https://github.com/tensorflow/tflite-micro).
* `--manifest_file`

    Specifies which `manifest` file to use.  The `manifest` uses Windows INI
    format, and [MANIFEST.ini](MANIFEST.ini) is the default.
* `--is_dry_run`

    A debugging flag.  All actions that would have been taken are output, but
    not executed.

The operation of the [create_tflm_arduino](create_tflm_arduino.py) script is
to copy files from the
[Arduino Examples repository](https://github.com/tensorflow/tflite-micro-arduino-examples)
and the `base directory` to the `output directory`.  Depending on file source
and suffix, a content and/or file name transformation is applied.  The `manifest`
contains directives that determine which files are copied to the `output directory`
as well as additional content transforms to apply.

The `base directory` is created using the
[create_tflm_tree](https://github.com/tensorflow/tflite-micro/blob/main/tensorflow/lite/micro/tools/project_generation/create_tflm_tree.py) script.  This script allows for a specific
platform target to be chosen, as well as which TFLM example applications are to be
included in the `base directory`.

## Detailed steps of the [create_tflm_arduino](create_tflm_arduino.py) script
1. Parse script arguments

    The script command-line arguments are parsed.

1. Parse `manifest` file

    Generate the following lists from the `manifest` directives:

    * Files that will be copied from the repository to the `output directory`
    * Files that will not be copied from the `base directory` to the `output directory`
    * Files that will be copied from the repository to the `output directory`
        with a changed file name/path
    * Files that will be copied from the `base directory` to the `output directory`
        with a changed file name/path
    * Files in the `output directory` that will be transformed by a `sed`
        regular-expression script

    Each of these lists are used as filters in subsequent path tuple generation
    operations.

1. Clean the `output directory`

    Removes any files or directories in the `output directory`

1. Generate list of tuples of base paths which will be transformed

    Each tuple in the list consists of a source path relative to the `base directory`,
    and a destination path relative to the `output directory`.

    The list is initially all files in the `base directory`,
    and is filtered by the `manifest` directives applicable to source paths
    in the `base directory`.

    The list is again filtered such that only source paths with the following suffixes
    are included: `.c .cc .cpp .h .ino`

    All destination paths with a `.cc` suffix are changed to a `.cpp` suffix.

1. Generate list of tuples of base paths that will not be transformed

    Each tuple in the list consists of a source path relative to the `base directory`,
    and a destination path relative to the `output directory`.

    The list is initially all files in the `base directory`,
    and is filtered by the `manifest` directives applicable to source paths
    in the `base directory`.

    The list is again filtered such that only source paths with the following suffixes
    are excluded: `.c .cc .cpp .h .ino`

1. Generate list of tuples of repository paths which will be transformed

    Each tuple in the list consists of a source path relative to the repository,
    and a destination path relative to the `output directory`.

    The list is generated by the `manifest` directives applicable to source paths
    in the repository.

    The list is filtered such that only source paths with the following suffixes
    are included: `.c .cc .cpp .h .ino`

    The list is again filtered such that it includes only files whose source
    path is within the `src/third_party` directory tree.

1. Generate list of tuples of repository paths that will not be transformed

    Each tuple in the list consists of a source path relative to the repository,
    and a destination path relative to the `output directory`.

    The list is generated by the `manifest` directives applicable to source paths
    in the repository.

    The list is filtered such that only source paths with the following suffixes
    are excluded: `.c .cc .cpp .h .ino`

    The suffix exclusion filter is only applied where the source
    path is within the `src/third_party` directory tree.

1. Create directory tree in `output directory`

    The previously generated lists of paths are used to create the directory
    tree structure in `output directory`.  Only directories are created, in
    preparation for subsequent file copy operations.

1. Generate dictionary of header files

    A dictionary is generated where the keys are the names of the example
    applications. The value for each dictionary entry is a list of header
    file paths.  The list of header file paths represents header files in
    the `output directory`, residing within each example application and
    under the `src/third_party` directory.
    
    An additional default key entry is also generated.
    The value for this dictionary entry is a list of header
    file paths.  The list of header file paths represents header files in
    the `output directory`,
    under the `src/third_party` directory.

    This dictionary of header files is used as an input parameter to the
    [transform_source](transform_source.py) script.

1. Transform and copy files in the list of base paths

    The list of base paths which will be transformed is used to copy
    files from the `base directory` to the `output directory`.
    Each file to be copied is transformed using the
    [transform_source](transform_source.py) script.

1. Transform and copy files in the list of repository paths

    The list of repository paths which will be transformed is used to copy
    files from the repository to the `output directory`.
    Each file to be copied is transformed using the
    [transform_source](transform_source.py) script.

1. Copy files with no transform in the list of base paths

    The list of base paths that will not be transformed is used to copy
    files from the `base directory` to the `output directory`.

1. Copy files with no transform in the list of repository paths

    The list of repository paths that will not be transformed is used to copy
    files from the repository to the `output directory`.

1. Flatten file tree of the example applications in the `output directory`

    Some example applications have sub-directories.  These sub-directories must
    be flattened to make the example applications compatible with the Arduino
    IDE.  This flatenning causes all sub-directory files to be moved to the
    top-level directories of the example applications.  The script
    [fix_arduino_subfolders](fix_arduino_subfolders.py) performs the flattening
    operation.

1. Patch files in `output directory` using `manifest` directives

    The files in the `output directory` have `sed` regular-expression script
    directives applied as specified in the `manifest`.

1. Remove empty directories in the `output directory`

    Remove any empty directories that are a result of the previous step of
    flattening the example application directories.
